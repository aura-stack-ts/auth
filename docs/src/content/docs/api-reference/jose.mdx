---
title: "@aura-stack/jose"
description: JOSE utilities for JWT signing, verification, and encryption
---

## JOSE API Reference

`@aura-stack/jose` provides a curated API surface for working with **JWS**, **JWE**, and **JWT** standards.  
It also includes a convenience re-export of the official [`jose`](https://github.com/panva/jose) library via the path `@aura-stack/jose/jose`, allowing consumers to access low-level cryptographic primitives when needed.

```ts lineNumbers
import { createJWT, createJWS, createJWE } from "@aura-stack/jose"

// JWSs (Json Web Signature)
export const { signJWS, verifyJWS } = createJWS("secret-key")

// JWEs (Json Web Encription)
export const { encryptJWE, decryptJWE } = createJWE("secret-key")

// JWTs (Json Web Token)
export const { encodeJWT, decodeJWT } = createJWT("secret-key")
```

---

## What you'll learn

Through this api reference documentation you are going to learn and understand from basic to advanced about the `JOSE` API Reference:

- [Features](#features)
- [Installation](#installation)
- [API Reference](#api-reference)
  - [Signing and Encrypting a JWT](#signing-and-encrypting-a-jwt)
  - [Signing API](#signing-api-jws)
  - [Encryption API](#encryption-api-jwe)
  - [Key Derivation](#key-derivation)

---

## Features

- **Direct re-export of `jose`** — access all primitives from the upstream package via `@aura-stack/jose/jose`.
- **JWE utilities** — use `createJWE`, `encryptJWE`, and `decryptJWE` for encryption/decryption flows.
- **JWS utilities** — use `createJWS`, `signJWS`, and `verifyJWS` for signature and verification.
- **JWT helpers** — use `createJWT`, `encodeJWT`, and `decodeJWT` for signing and encrypting JSON Web Tokens.
- **Secure by design** — built on top of modern JOSE standards (RFC 7515, 7516, 7519).
- **Key derivation** — use `deriveKey` for key derivation

---

## Installation

If you haven’t installed the package yet:

```npm
npm install @aura-stack/jose
```

<Callout>
  The `@aura-stack/jose` package is already included as a dependency of `@aura-stack/auth`. You only need to install it separately
  if you want to use it standalone.
</Callout>

---

## API Reference

## Signing and Encrypting a JWT

### `encodeJWT(payload, secret)`

Encodes a JWT by first signing it (JWS) and then encrypting it (JWE). This ensures both **integrity** and **confidentiality** as recommended by [RFC 7519 #11.2](https://datatracker.ietf.org/doc/html/rfc7519#section-11.2).

```ts lineNumbers
type encodeJWT = (token: JWTPayload, secret: SecretInput) => Promise<string>
```

#### Parameters

| Parameter | Type          | Description                           |
| --------- | ------------- | ------------------------------------- |
| `token`   | `JWTPayload`  | Payload data to encode in the JWT     |
| `secret`  | `SecretInput` | Secret key for signing and encrypting |

#### Returns

Promise resolving to the signed and encrypted JWT string.

#### Example

```ts lineNumbers
import { encodeJWT } from "@aura-stack/jose"

const token = await encodeJWT(
  {
    sub: "user-123",
    email: "user@example.com",
    role: "admin",
  },
  process.env.JWT_SECRET!
)

console.log(token) // eyJhbGciOiJkaXIiLCJlbmMiOiJBMjU2R0NNIi...
```

<Callout type="info">The token is first signed using HS256, then encrypted using A256GCM.</Callout>

---

### `decodeJWT(token, secret)`

Decodes a JWT by first decrypting it (JWE) and then verifying it (JWS). This validates both **confidentiality** and **integrity**.

#### Signature

```ts lineNumbers
function decodeJWT(token: string, secret: SecretInput): Promise<JWTPayload>
```

#### Parameters

| Parameter | Type          | Description                             |
| --------- | ------------- | --------------------------------------- |
| `token`   | `string`      | Encoded JWT string to decode            |
| `secret`  | `SecretInput` | Secret key for decrypting and verifying |

#### Returns

Promise resolving to the decoded JWT payload.

#### Example

```ts lineNumbers
import { decodeJWT } from "@aura-stack/jose"

try {
  const payload = await decodeJWT(token, process.env.JWT_SECRET!)

  console.log(payload.sub) // 'user-123'
  console.log(payload.email) // 'user@example.com'
  console.log(payload.exp) // 1234567890 (expiration timestamp)
} catch (error) {
  console.error("Invalid or expired token")
}
```

---

### `createJWT(secret)`

Creates a JWT handler with bound `encodeJWT` and `decodeJWT` methods.

#### Signature

```ts lineNumbers
function createJWT(secret: SecretInput): {
  encodeJWT: (payload: JWTPayload) => Promise<string>
  decodeJWT: (token: string) => Promise<JWTPayload>
}
```

#### Parameters

| Parameter | Type          | Description                       |
| --------- | ------------- | --------------------------------- |
| `secret`  | `SecretInput` | Secret key for all JWT operations |

#### Returns

Object with `encodeJWT` and `decodeJWT` methods.

#### Example

```ts lineNumbers
import { createJWT } from "@aura-stack/jose"

const jwt = createJWT(process.env.JWT_SECRET!)

// Encode
const token = await jwt.encodeJWT({ sub: "user-123" })

// Decode
const payload = await jwt.decodeJWT(token)
```

## Signing API (JWS)

### `signJWS(payload, secret)`

Signs a JWT using HS256 algorithm with standard claims.

#### Signature

```ts lineNumbers
function signJWS(payload: JWTPayload, secret: SecretInput): Promise<string>
```

#### Generated Claims

The following claims are automatically added:

| Claim | Description                      |
| ----- | -------------------------------- |
| `alg` | Algorithm: `HS256`               |
| `typ` | Type: `JWT`                      |
| `iat` | Issued At: Current timestamp     |
| `nbf` | Not Before: Current timestamp    |
| `exp` | Expiration: 15 days from now     |
| `jti` | JWT ID: Random unique identifier |

#### Example

```ts lineNumbers
import { signJWS } from "@aura-stack/jose"

const signed = await signJWS(
  {
    sub: "user-123",
    email: "user@example.com",
  },
  process.env.JWT_SECRET!
)

// Result: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

---

### `verifyJWS(token, secret)`

Verifies a signed JWT and returns the payload if valid.

#### Signature

```ts lineNumbers
function verifyJWS(token: string, secret: SecretInput): Promise<JWTPayload>
```

#### Security

- Rejects tokens using the "none" algorithm (unsecured JWTs)
- Validates signature integrity
- Checks expiration automatically

#### Example

```ts lineNumbers
import { verifyJWS } from "@aura-stack/jose"

try {
  const payload = await verifyJWS(signed, process.env.JWT_SECRET!)
  console.log("Valid token:", payload)
} catch (error) {
  console.error("Invalid token:", error.message)
}
```

---

### `createJWS(secret)`

Creates a JWS handler with bound signing and verification methods.

#### Signature

```ts lineNumbers
function createJWS(secret: SecretInput): {
  signJWS: (payload: JWTPayload) => Promise<string>
  verifyJWS: (token: string) => Promise<JWTPayload>
}
```

#### Example

```ts lineNumbers
import { createJWS } from "@aura-stack/jose"

const jws = createJWS(process.env.JWT_SECRET!)

const signed = await jws.signJWS({ sub: "user-123" })
const payload = await jws.verifyJWS(signed)
```

## Encryption API (JWE)

### `encryptJWE(payload, secret)`

Encrypts a JWT string using A256GCM encryption.

#### Signature

```ts lineNumbers
function encryptJWE(payload: string, secret: SecretInput): Promise<string>
```

#### Generated Claims

| Claim | Description                          |
| ----- | ------------------------------------ |
| `alg` | Algorithm: `dir` (direct encryption) |
| `enc` | Encryption: `A256GCM`                |
| `typ` | Type: `JWT`                          |
| `cty` | Content Type: `JWT`                  |
| `iat` | Issued At: Current timestamp         |
| `nbf` | Not Before: Current timestamp        |
| `exp` | Expiration: 15 days from now         |
| `jti` | JWT ID: Random unique identifier     |

#### Example

```ts lineNumbers
import { encryptJWE } from "@aura-stack/jose"

const encrypted = await encryptJWE("signed-jwt-token-here", process.env.ENCRYPTION_KEY!)
```

---

### `decryptJWE(token, secret)`

Decrypts an encrypted JWT and returns the original payload string.

#### Signature

```ts lineNumbers
function decryptJWE(token: string, secret: SecretInput): Promise<string>
```

#### Example

```ts lineNumbers
import { decryptJWE } from "@aura-stack/jose"

try {
  const decrypted = await decryptJWE(encrypted, process.env.ENCRYPTION_KEY!)
  console.log("Decrypted JWT:", decrypted)
} catch (error) {
  console.error("Decryption failed:", error.message)
}
```

---

### `createJWE(secret)`

Creates a JWE handler with bound encryption and decryption methods.

#### Signature

```ts lineNumbers
function createJWE(secret: SecretInput): {
  encryptJWE: (payload: string) => Promise<string>
  decryptJWE: (token: string) => Promise<string>
}
```

#### Example

```ts lineNumbers
import { createJWE } from "@aura-stack/jose"

const jwe = createJWE(process.env.ENCRYPTION_KEY!)

const encrypted = await jwe.encryptJWE("data-to-encrypt")
const decrypted = await jwe.decryptJWE(encrypted)
```

## Key Derivation

### `deriveKey(secret, info, len)`

Create a Key derivation which implements HKDF

#### Signature

```ts lineNumbers
import type { SecretInput } from "@aura-stack/jose"
function deriveKey(
  secret: SecretInput,
  info: string,
  len: number
): {
  key: ArrayBuffer
  deriveKey: Buffer<ArrayBuffer>
}
```

#### Example

```ts lineNumbers
import { deriveKey } from "@aura-stack/jose/hkdf"

const secret = "secret-key"

const sessionKey = deriveKey(secret, "session key", 32)
const databaseKey = deriveKey(secret, "database key", 64)
```

### `createDeriveKey(secret, info, len)`

Creates a key derivation function that includes verification for the key length. It implements the `deriveKey` function.

#### Signature

```ts lineNumbers
import type { SecretInput } from "@aura-stack/jose"

function createDeriveKey(
  secret: SecretInput,
  info: string,
  len: number
): {
  key: ArrayBuffer
  deriveKey: Buffer<ArrayBuffer>
}
```

#### Example

```ts lineNumbers
import { createDeriveKey } from "@aura-stack/jose/hkdf"

const secret = "secret-key"

const sessionKey = createDeriveKey(secret, "session key", 32)
const databaseKey = createDeriveKey(secret, "database key", 64)
```

---

## Types

### `SecretInput`

Flexible secret key input type.

```ts lineNumbers
type SecretInput = KeyObject | Uint8Array | string
```

Accepts:

- `KeyObject` - Node.js crypto key
- `string` - String secret (converted internally)
- `Uint8Array` - Binary secret

### `JWTPayload`

Standard JWT payload with registered claims.

```ts lineNumbers
interface JWTPayload {
  iss?: string // Issuer
  sub?: string // Subject (user ID)
  aud?: string | string[] // Audience
  exp?: number // Expiration time
  nbf?: number // Not before
  iat?: number // Issued at
  jti?: string // JWT ID
  [key: string]: any // Custom claims
}
```

## Security Best Practices

<Callout type="warn">**Critical Security Guidelines**</Callout>

<Steps>

<Step>

### Strong Secrets

Always use cryptographically secure random strings:

```ts lineNumbers
// ✅ Good: Strong random secret
import crypto from "node:crypto"
const secret = crypto.randomBytes(32).toString("hex")

// ❌ Bad: Weak predictable secret
const secret = "password123"
```

</Step>

<Step>

### Environment Variables

Never hardcode secrets:

```ts lineNumbers
// ✅ Good: Environment variable
const secret = process.env.JWT_SECRET

// ❌ Bad: Hardcoded secret
const secret = "my-secret-key-12345"
```

</Step>

<Step>

### Token Expiration

Tokens automatically expire after 15 days. For custom expiration, use the underlying `jose` library directly.

</Step>

<Step>

### HTTPS Only

Always transmit JWTs over HTTPS in production to prevent token interception.

</Step>

<Step>

### Token Storage

- **Backend**: Store in secure HTTP-only cookies
- **Frontend**: Avoid `localStorage` - use cookies or session storage with caution

</Step>

</Steps>

---

## Usage

### With Session Management

```ts lineNumbers
import { encodeJWT, decodeJWT } from "@aura-stack/jose"

// Create session token
async function createSession(userId: string) {
  return await encodeJWT(
    {
      sub: userId,
      type: "session",
      createdAt: Date.now(),
    },
    process.env.SESSION_SECRET!
  )
}

// Validate session token
async function validateSession(token: string) {
  try {
    const payload = await decodeJWT(token, process.env.SESSION_SECRET!)

    if (payload.type !== "session") {
      throw new Error("Invalid token type")
    }

    return payload.sub // Return user ID
  } catch {
    return null // Invalid or expired
  }
}

// Usage
const token = await createSession("user-123")
const userId = await validateSession(token)

if (userId) {
  console.log("Valid session for user:", userId)
}
```

## Underlying Library

This package is built on top of [`jose`](https://github.com/panva/jose) - a robust implementation of JOSE standards. For advanced use cases, you can access the underlying library directly:

```ts lineNumbers
import * as jose from "jose"

// Full access to jose library
const key = await jose.generateSecret("HS256")
const jwt = await new jose.SignJWT({ foo: "bar" }).setProtectedHeader({ alg: "HS256" }).sign(key)
```
