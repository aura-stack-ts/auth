---
title: JOSE API Reference
description: Complete API documentation for @aura-stack/jose - JWT signing, verification, and encryption
---

import { Callout } from "fumadocs-ui/components/callout"
import { Tab, Tabs } from "fumadocs-ui/components/tabs"

## Installation

<Tabs items={["pnpm", "npm", "yarn"]}>
  <Tab value="pnpm">```bash pnpm add @aura-stack/jose ```</Tab>
  <Tab value="npm">```bash npm install @aura-stack/jose ```</Tab>
  <Tab value="yarn">```bash yarn add @aura-stack/jose ```</Tab>
</Tabs>

## Overview

`@aura-stack/jose` provides utilities for JWT operations following [RFC 7519](https://datatracker.ietf.org/doc/html/rfc7519) standards. It implements nested JWTs with both signing (JWS) and encryption (JWE) for maximum security.

## High-Level API

### `encodeJWT(payload, secret)`

Encodes a JWT by first signing it (JWS) and then encrypting it (JWE). This ensures both **integrity** and **confidentiality** as recommended by [RFC 7519 §11.2](https://datatracker.ietf.org/doc/html/rfc7519#section-11.2).

#### Signature

```typescript
function encodeJWT(token: JWTPayload, secret: SecretInput): Promise<string>
```

#### Parameters

| Parameter | Type          | Description                           |
| --------- | ------------- | ------------------------------------- |
| `token`   | `JWTPayload`  | Payload data to encode in the JWT     |
| `secret`  | `SecretInput` | Secret key for signing and encrypting |

#### Returns

Promise resolving to the signed and encrypted JWT string.

#### Example

```typescript
import { encodeJWT } from "@aura-stack/jose"

const token = await encodeJWT(
  {
    sub: "user-123",
    email: "user@example.com",
    role: "admin",
  },
  process.env.JWT_SECRET!
)

console.log(token) // eyJhbGciOiJkaXIiLCJlbmMiOiJBMjU2R0NNIi...
```

<Callout type="info">The token is first signed using HS256, then encrypted using A256GCM.</Callout>

---

### `decodeJWT(token, secret)`

Decodes a JWT by first decrypting it (JWE) and then verifying it (JWS). This validates both **confidentiality** and **integrity**.

#### Signature

```typescript
function decodeJWT(token: string, secret: SecretInput): Promise<JWTPayload>
```

#### Parameters

| Parameter | Type          | Description                             |
| --------- | ------------- | --------------------------------------- |
| `token`   | `string`      | Encoded JWT string to decode            |
| `secret`  | `SecretInput` | Secret key for decrypting and verifying |

#### Returns

Promise resolving to the decoded JWT payload.

#### Example

```typescript
import { decodeJWT } from "@aura-stack/jose"

try {
  const payload = await decodeJWT(token, process.env.JWT_SECRET!)

  console.log(payload.sub) // 'user-123'
  console.log(payload.email) // 'user@example.com'
  console.log(payload.exp) // 1234567890 (expiration timestamp)
} catch (error) {
  console.error("Invalid or expired token")
}
```

---

### `createJWT(secret)`

Creates a JWT handler with bound `encodeJWT` and `decodeJWT` methods.

#### Signature

```typescript
function createJWT(secret: SecretInput): {
  encodeJWT: (payload: JWTPayload) => Promise<string>
  decodeJWT: (token: string) => Promise<JWTPayload>
}
```

#### Parameters

| Parameter | Type          | Description                       |
| --------- | ------------- | --------------------------------- |
| `secret`  | `SecretInput` | Secret key for all JWT operations |

#### Returns

Object with `encodeJWT` and `decodeJWT` methods.

#### Example

```typescript
import { createJWT } from "@aura-stack/jose"

const jwt = createJWT(process.env.JWT_SECRET!)

// Encode
const token = await jwt.encodeJWT({ sub: "user-123" })

// Decode
const payload = await jwt.decodeJWT(token)
```

## Signing API (JWS)

### `signJWS(payload, secret)`

Signs a JWT using HS256 algorithm with standard claims.

#### Signature

```typescript
function signJWS(payload: JWTPayload, secret: SecretInput): Promise<string>
```

#### Generated Claims

The following claims are automatically added:

| Claim | Description                      |
| ----- | -------------------------------- |
| `alg` | Algorithm: `HS256`               |
| `typ` | Type: `JWT`                      |
| `iat` | Issued At: Current timestamp     |
| `nbf` | Not Before: Current timestamp    |
| `exp` | Expiration: 15 days from now     |
| `jti` | JWT ID: Random unique identifier |

#### Example

```typescript
import { signJWS } from "@aura-stack/jose"

const signed = await signJWS(
  {
    sub: "user-123",
    email: "user@example.com",
  },
  process.env.JWT_SECRET!
)

// Result: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

---

### `verifyJWS(token, secret)`

Verifies a signed JWT and returns the payload if valid.

#### Signature

```typescript
function verifyJWS(token: string, secret: SecretInput): Promise<JWTPayload>
```

#### Security

- Rejects tokens using the "none" algorithm (unsecured JWTs)
- Validates signature integrity
- Checks expiration automatically

#### Example

```typescript
import { verifyJWS } from "@aura-stack/jose"

try {
  const payload = await verifyJWS(signed, process.env.JWT_SECRET!)
  console.log("Valid token:", payload)
} catch (error) {
  console.error("Invalid token:", error.message)
}
```

---

### `createJWS(secret)`

Creates a JWS handler with bound signing and verification methods.

#### Signature

```typescript
function createJWS(secret: SecretInput): {
  signJWS: (payload: JWTPayload) => Promise<string>
  verifyJWS: (token: string) => Promise<JWTPayload>
}
```

#### Example

```typescript
import { createJWS } from "@aura-stack/jose"

const jws = createJWS(process.env.JWT_SECRET!)

const signed = await jws.signJWS({ sub: "user-123" })
const payload = await jws.verifyJWS(signed)
```

## Encryption API (JWE)

### `encryptJWE(payload, secret)`

Encrypts a JWT string using A256GCM encryption.

#### Signature

```typescript
function encryptJWE(payload: string, secret: SecretInput): Promise<string>
```

#### Generated Claims

| Claim | Description                          |
| ----- | ------------------------------------ |
| `alg` | Algorithm: `dir` (direct encryption) |
| `enc` | Encryption: `A256GCM`                |
| `typ` | Type: `JWT`                          |
| `cty` | Content Type: `JWT`                  |
| `iat` | Issued At: Current timestamp         |
| `nbf` | Not Before: Current timestamp        |
| `exp` | Expiration: 15 days from now         |
| `jti` | JWT ID: Random unique identifier     |

#### Example

```typescript
import { encryptJWE } from "@aura-stack/jose"

const encrypted = await encryptJWE("signed-jwt-token-here", process.env.ENCRYPTION_KEY!)
```

---

### `decryptJWE(token, secret)`

Decrypts an encrypted JWT and returns the original payload string.

#### Signature

```typescript
function decryptJWE(token: string, secret: SecretInput): Promise<string>
```

#### Example

```typescript
import { decryptJWE } from "@aura-stack/jose"

try {
  const decrypted = await decryptJWE(encrypted, process.env.ENCRYPTION_KEY!)
  console.log("Decrypted JWT:", decrypted)
} catch (error) {
  console.error("Decryption failed:", error.message)
}
```

---

### `createJWE(secret)`

Creates a JWE handler with bound encryption and decryption methods.

#### Signature

```typescript
function createJWE(secret: SecretInput): {
  encryptJWE: (payload: string) => Promise<string>
  decryptJWE: (token: string) => Promise<string>
}
```

#### Example

```typescript
import { createJWE } from "@aura-stack/jose"

const jwe = createJWE(process.env.ENCRYPTION_KEY!)

const encrypted = await jwe.encryptJWE("data-to-encrypt")
const decrypted = await jwe.decryptJWE(encrypted)
```

## Types

### `SecretInput`

Flexible secret key input type.

```typescript
type SecretInput = CryptoKey | KeyObject | string | Uint8Array
```

Accepts:

- `CryptoKey` - Web Crypto API key
- `KeyObject` - Node.js crypto key
- `string` - String secret (converted internally)
- `Uint8Array` - Binary secret

### `JWTPayload`

Standard JWT payload with registered claims.

```typescript
interface JWTPayload {
  iss?: string // Issuer
  sub?: string // Subject (user ID)
  aud?: string | string[] // Audience
  exp?: number // Expiration time
  nbf?: number // Not before
  iat?: number // Issued at
  jti?: string // JWT ID
  [key: string]: any // Custom claims
}
```

## Security Best Practices

<Callout type="warn">**Critical Security Guidelines**</Callout>

### 1. Strong Secrets

Always use cryptographically secure random strings:

```typescript
// ✅ Good: Strong random secret
import crypto from "node:crypto"
const secret = crypto.randomBytes(32).toString("hex")

// ❌ Bad: Weak predictable secret
const secret = "password123"
```

### 2. Environment Variables

Never hardcode secrets:

```typescript
// ✅ Good: Environment variable
const secret = process.env.JWT_SECRET

// ❌ Bad: Hardcoded secret
const secret = "my-secret-key-12345"
```

### 3. Token Expiration

Tokens automatically expire after 15 days. For custom expiration, use the underlying `jose` library directly.

### 4. HTTPS Only

Always transmit JWTs over HTTPS in production to prevent token interception.

### 5. Token Storage

- **Backend**: Store in secure HTTP-only cookies
- **Frontend**: Avoid `localStorage` - use cookies or session storage with caution

## Complete Example

### Session Management

```typescript
import { encodeJWT, decodeJWT } from "@aura-stack/jose"

// Create session token
async function createSession(userId: string) {
  return await encodeJWT(
    {
      sub: userId,
      type: "session",
      createdAt: Date.now(),
    },
    process.env.SESSION_SECRET!
  )
}

// Validate session token
async function validateSession(token: string) {
  try {
    const payload = await decodeJWT(token, process.env.SESSION_SECRET!)

    if (payload.type !== "session") {
      throw new Error("Invalid token type")
    }

    return payload.sub // Return user ID
  } catch {
    return null // Invalid or expired
  }
}

// Usage
const token = await createSession("user-123")
const userId = await validateSession(token)

if (userId) {
  console.log("Valid session for user:", userId)
}
```

### Refresh Token Pattern

```typescript
import { createJWT } from "@aura-stack/jose"

const accessJWT = createJWT(process.env.ACCESS_SECRET!)
const refreshJWT = createJWT(process.env.REFRESH_SECRET!)

async function generateTokens(userId: string) {
  const accessToken = await accessJWT.encodeJWT({
    sub: userId,
    type: "access",
  })

  const refreshToken = await refreshJWT.encodeJWT({
    sub: userId,
    type: "refresh",
  })

  return { accessToken, refreshToken }
}

async function refreshAccessToken(refreshToken: string) {
  try {
    const payload = await refreshJWT.decodeJWT(refreshToken)

    if (payload.type !== "refresh") {
      throw new Error("Invalid token type")
    }

    return await accessJWT.encodeJWT({
      sub: payload.sub,
      type: "access",
    })
  } catch {
    throw new Error("Invalid refresh token")
  }
}
```

### Encrypted User Data

```typescript
import { createJWS, createJWE } from "@aura-stack/jose"

const jws = createJWS(process.env.SIGNING_KEY!)
const jwe = createJWE(process.env.ENCRYPTION_KEY!)

async function encryptUserData(data: any) {
  // First sign the data
  const signed = await jws.signJWS(data)

  // Then encrypt it
  return await jwe.encryptJWE(signed)
}

async function decryptUserData(token: string) {
  // First decrypt
  const decrypted = await jwe.decryptJWE(token)

  // Then verify
  return await jws.verifyJWS(decrypted)
}
```

## Error Handling

All functions throw errors for invalid inputs or operations:

```typescript
import { decodeJWT } from "@aura-stack/jose"

try {
  const payload = await decodeJWT(token, secret)
} catch (error) {
  if (error.message === "Failed to decode JWT") {
    // Token is invalid, expired, or tampered with
    console.error("Invalid token:", error.cause)
  }
}
```

## Underlying Library

This package is built on top of [`jose`](https://github.com/panva/jose) - a robust implementation of JOSE standards. For advanced use cases, you can access the underlying library directly:

```typescript
import * as jose from "jose"

// Full access to jose library
const key = await jose.generateSecret("HS256")
const jwt = await new jose.SignJWT({ foo: "bar" }).setProtectedHeader({ alg: "HS256" }).sign(key)
```

## Related Documentation

<Cards>
  <Card title="Core API" href="/docs/api/core">
    Authentication API documentation
  </Card>
  <Card title="Security Guide" href="/docs/guides/security">
    Security best practices
  </Card>
  <Card title="jose Library" href="https://github.com/panva/jose">
    Underlying JOSE library docs
  </Card>
  <Card title="RFC 7519" href="https://datatracker.ietf.org/doc/html/rfc7519">
    JWT Standard Specification
  </Card>
</Cards>
