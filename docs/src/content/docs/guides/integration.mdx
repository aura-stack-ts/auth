---
title: Integration Guide
description: Learn how to integrate Aura Auth with any JavaScript library or framework
---

Aura Auth is a framework-agnostic and modular API to implement authentication and authorization flows for TypeScript applications based on the web standards communications and protocols that includes ([`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request) and [`Response`](https://developer.mozilla.org/en-US/docs/Web/API/Response)) Web Interfaces and [OAuth 2.0 Authorization Framework](https://datatracker.ietf.org/doc/html/rfc6749) protocol.

<Callout>
  The library or framework that wants to implement Aura Auth should include at least support for server or backend
  applications. This is because Aura Auth interacts with the integration via `GET` and `POST` handlers which communicate with the Aura
  Auth internal workflow.
</Callout>

---

## What you'll learn

This guide explains and demonstrates how to integrate Aura Auth with any framework or library based on native TypeScript runtimes.

- [Core Concepts](#core-concepts)
  - [Aura Auth Instance](#aura-auth-instance)
  - [HTTP Handlers](#http-handlers)
  - [Server](#server)
  - [Client](#client)
- [Resources](#resources)

---

## Core Concepts

### Aura Auth Instance

The `createAuth` function is the entry function of the package which creates the Aura Auth instance configuration that defines the behavior, the options and values to be supported by the Auth Instance this includes the definitions of the [OAuth Providers](/docs/oauth) to be consumed, [Cookie Management](/docs/guides/cookie-management) and more configurable options, for more details read [createAuth API Reference](/docs/api-reference/core#create-auth).

```ts title="@/auth.ts" lineNumbers
import { createAuth } from "@aura-stack/auth"

export const auth = createAuth({
  oauth: [],
})
```

> It's recommended to name the auth file to `auth.ts`

The `createAuth` function returns `jose` and `handlers` objects that contains a powerful utilities and important functions to the Aura Auth flow.

### HTTP Handlers

The HTTP handlers are the HTTP methods supported in the Aura Auth flow (`GET` and `POST`) which includes pre-built routes used in the Auth flows (`/signIn/:oauth`, `/callback/:oauth`, `/session`, `signOut` and `csrfToken`) and must be mounted to the router or backend to have a complete and full support to authentication and authorization provided by Aura Auth.

By default the handlers must be mounted in the `/auth` route of the server backend of the integration. However, it's possible to rewrite it using `basePath` configuration option in the `createAuth` function.

```ts title="@/auth.ts" lineNumbers
import { createAuth } from "@aura-stack/auth"

export const auth = createAuth({
  oauth: [],
  basePath: "/auth",
})

export const { handlers, jose } = auth
```

These handlers internally provide:

| Route              | Description                                   |
| ------------------ | --------------------------------------------- |
| `/signIn/:oauth`   | Starts the OAuth flow (Authorization Request) |
| `/callback/:oauth` | Completes the OAuth flow and issues a session |
| `/session`         | Returns the current session                   |
| `/signOut`         | invalidates the active session                |
| `/csrfToken`       | Generates a CSRF token (for forms)            |

<Callout type="warning">
  The usage of the HTTP handlers depends of the library and frameworks integration, just, Aura Auth provides the endpoint for the
  `Aura Auth` flows.
</Callout>

### Server

#### Mount HTTP Handlers

The integration should provide support to the server or backend application. Because it is required to mount the HTTP Handlers (`handlers`) obtained by the Aura Auth instance via `createAuth` that includes `GET` and `POST` HTTP handlers that must be mounted in a server or router that dispatches the actions made by the interaction between the web application (client) and the Aura Auth flows.

```ts title="@/server.ts" lineNumbers
import { handlers } from "@/auth"

export const authRequest = (request: Request) => {
  const method = request.method
  if (method === "GET") {
    return handlers.GET(request)
  }
  if (method === "POST") {
    return handlers.POST(request)
  }
  return Response.json(
    {
      message: "Bad Request",
    },
    { statusCode: 400 }
  )
}
```

#### Sign In [#sign-in-server]

To sign in, simply redirect the user's browser to the sign-in endpoint for the chosen provider. See [Sign In in Client](#sign-in-client).

#### Get session [#get-session-server]

To get the current or active session in the server side fetch to `/session` endpoint. See [Get Session in Server](#get-session-server)

```ts title="@/auth/server.ts" lineNumbers
export const getSession = async () => {
  const baseURL = getBaseURL()
  const cookies = getCookies()

  const response = await fetch(`${baseURL}/auth/session`, {
    method: "GET,
    cache: "no-store",
    headers: { "Cookie": cookies }
  })
  if (response.ok) {
    const session = await response.json()
    return session
  }
  return null
}
```

<Callout type="warning">
  In the Server Side is required to manipulate directly the headers and cookies using the built-in functions to the library and
  frameworks, due to headers aren't loaded automatically. In this case `getBaseURL` and `getCookies` aren't real functions, it
  simulates built-in functions that allows to extract data of the request.
</Callout>

#### CSRF Token [#csrf-token-server]

For critical and mutation actions (like Sign Out), Aura Auth employs a CSRF protection mechanism that ensures that critical actions are made by the original user. Otherwise, if the CSRF Token is not provided the action isn't going to be possible. For more details read [CSRF Protection](/docs/concepts/security-model#csrf-protection). See [CSRF Token in Client](#csrf-token-client).

##### Get CSRF Token [!toc]

Once is fetched the `/csrfToken` endpoint Aura Auth internally verifies if the token was generated before or not. If it was, its verified, otherwise is generated and stored in `csrf_token` cookie.

```ts title="@/auth/server.ts" lineNumbers
export const getCsrfToken = async () => {
  const baseURL = getBaseURL()
  const headers = getHeaders()

  const response = await fetch(`${baseURL}/auth/csrfToken`, {
    method: "GET",
    cache: "no-store",
    headers,
  })
  const data = await response.json()
  return data.csrfToken
}
```

<Callout type="warning">
  In the Server Side is required to manipulate directly the headers and cookies using the built-in functions to the library and
  frameworks, due to headers aren't loaded automatically. In this case `getBaseURL` and `getHeaders` aren't real functions, it
  simulates built-in functions that allows to extract data of the request.
</Callout>

#### Sign Out [#sign-out-server]

To sign out the active session, the request must `POST` to `/signOut` endpoint. The request must include the CSRF token, preferably via the `X-CSRF-Token` header. See [Sign Out in Client](#sign-out-client).

```ts title="@/auth/server.ts" lineNumbers
export const signOut = () => {
  const baseURL = getBaseURL()
  const cookies = getCookies()
  const csrfToken = await getCsrfToken()

  const response = await fetch(`${baseURL}/auth/signOut?token_type_hint=session_token`, {
    method: "POST",
    cache: "no-store",
    headers: {
      Cookie: cookies,
      "X-CSRF-Token": csrfToken,
      "Content-Type": "application/json",
    },
    body: JSON.stringify({}),
  })
  setHeaders(response.headers)
}
```

<Callout type="warning">
  In the Server Side is required to manipulate directly the headers and cookies using the built-in functions to the library and
  frameworks, due to headers aren't loaded automatically. In this case `getBaseURL`, `getCookies` and `setHeaders` aren't real
  functions, it simulates built-in functions that allows to extract data of the request.
</Callout>

---

### Client

Interacts with the exposed endpoints mounted by the HTTP handlers to communicate and acquire the state of the auth flow including getting the active session, sign out the session, sign-in and get the CSRF Token.

<Callout>

The browser (client) automatically loads the cookies and headers of the incoming request and response, so, there's no need to set them in the `fetch` request.

However, this case is different on the server side, which requires extra cookies and headers manipulation for a correct behavior.

</Callout>

#### Sign In [#sign-in-client]

To sign in, simply redirect the user's browser to the sign-in endpoint for the chosen provider.

```html title="index.html" lineNumbers
<form action="/auth/signIn/github">
  <input type="hidden" name="redirecTo" value="/" />
  <button>Sign in with GitHub</button>
</form>
```

**OR**

```html title="index.html" lineNumbers
<a href="/auth/signIn/github">Sign in with GitHub</a>
```

This initiates the OAuth flow, handling the redirect to the provider and the subsequent callback to your server or redirect to the defined path in the `redirectTo` search parameter. For more details about the Built-in oauth providers read [OAuth Providers](/docs/oauth).

#### Get session [#get-session-client]

To check the current or active session fetch to `/session` endpoint.

```ts title="@/auth/client.ts" lineNumbers
export const getBaseURL = () => {
  return typeof window !== "undefined" ? window.location.origin : ""
}

export const getSession = async () => {
  const baseURL = getBaseURL()
  const response = await fetch(`${baseURL}/auth/session`)
  if (response.ok) {
    const session = await response.json()
    return session
  }
  return null
}
```

#### CSRF Token [#csrf-token-client]

For critical and mutation actions (like Sign Out), Aura Auth employs a CSRF protection mechanism that ensures that critical actions are made by the original user. Otherwise, if the CSRF Token is not provided the action isn't going to be possible. For more details read [CSRF Protection](/docs/concepts/security-model#csrf-protection).

##### Get CSRF Token [!toc]

Once is fetched the `/csrfToken` endpoint Aura Auth internally verifies if the token was generated before or not. If it was, its verified, otherwise is generated and stored in `csrf_token` cookie.

```ts title="@/auth/client.ts" lineNumbers
export const getCsrfToken = async () => {
  const baseURL = getBaseURL()
  const response = await fetch(`${baseURL}/auth/csrfToken`)
  const data = await response.json()
  return data.csrfToken
}
```

#### Sign Out [#sign-out-client]

To sign out the active session, the request must `POST` to `/signOut` endpoint. The request must include the CSRF token, preferably via the `X-CSRF-Token` header.

```ts title="@/auth/client.ts" lineNumbers
export const signOut = () => {
  const baseURL = getBaseURL()
  const csrfToken = await getCsrfToken()

  await fetch(`${baseURL}/auth/signOut?token_type_hint=session_token`, {
    method: "POST",
    headers: {
      "X-CSRF-Token": csrfToken,
      "Content-Type": "application/json",
    },
    body: JSON.stringify({}),
  })

  window.location.reload()
}
```

<Callout type="warning">
  The `signOut` request must contain the `body` content and `application/json` content-type as a temporary solution to an error
  caused by `@aura-stack/router` otherwise it will respond with 422 status code (Unprocessable Content).
</Callout>

---

## Resources
